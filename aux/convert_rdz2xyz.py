#!/usr/bin/env python

# Generate lightcone for DESI mocks
# from HOD catalogues generated by Shadab

import sys
import os
import tracemalloc
import time
import configparser
import multiprocessing as mp

import camb
import numpy as np
import healpy as hp
import numexpr as ne
ne.set_num_threads(4)

from astropy.io import fits

import h5py

from rotation_matrix import RotationMatrix
		
def tp2rd(tht, phi):
	""" convert theta,phi to ra/dec """
	ra  = phi / np.pi * 180.0
	dec = -1 * (tht / np.pi * 180.0 - 90.0)
	return ra, dec

class LC():
	def __init__(self, config_file, args):
		config     = configparser.ConfigParser()
		config.read(config_file)

		self.file_camb      =  config.get('dir', 'file_camb')
		self.boxL           =  config.getint('sim', 'boxL')
		self.shellwidth     =  config.getint('sim', 'shellwidth')
		self.zmin       =  config.getfloat('sim', 'zmin')
		self.zmax       =  config.getfloat('sim', 'zmax')
		self.origin  = [0, 0, 0]
		self.clight  = 299792458.

		self.h, self.results = self.run_camb()
		file_alist     =  config.get('dir','file_alist')
		self.alist = np.loadtxt(file_alist)

		rotation_matrix_instance = RotationMatrix(config_file, args)
		self.rotation_matrix = rotation_matrix_instance.rotation_matrix


	def run_camb(self):
		#Load all parameters from camb file 
		start = time.time()
		pars = camb.read_ini(self.file_camb)
		h    = pars.h
		pars.set_for_lmax(2000, lens_potential_accuracy=3)
		pars.set_matter_power(redshifts=[0.], kmax=200.0)
		pars.NonLinearModel.set_params(halofit_version='takahashi')
		camb.set_feedback_level(level=100)
		results   = camb.get_results(pars)
		return h, results


	def compute_shellnums(self):
		start = time.time()
		shellnum_min = int(self.results.comoving_radial_distance(self.zmin)*self.h // self.shellwidth)
		shellnum_max = int(self.results.comoving_radial_distance(self.zmax)*self.h // self.shellwidth + 1)
		shellnums = list(range(shellnum_min, shellnum_max+1))
		return shellnums


	def checkslicehit(self, chilow, chihigh, xx, yy, zz):
		""" pre-select so that we're not loading non-intersecting blocks """
		boxL = self.boxL
		origin = self.origin
		bvx=np.array([0, boxL, boxL, 0,    0,    boxL, boxL, 0])
		bvy=np.array([0,    0, boxL, boxL, 0,    0,    boxL, boxL])
		bvz=np.array([0,    0,   0,  0,    boxL, boxL, boxL, boxL])

		boo = 0
		r   = np.zeros(8)
		for i in range(0, 8):
			sx  = (bvx[i] - origin[0] + boxL * xx);
			sy  = (bvy[i] - origin[1] + boxL * yy);
			sz  = (bvz[i] - origin[2] + boxL * zz);
			r[i]= np.sqrt(sx * sx + sy * sy + sz * sz)
		if chihigh<np.min(r):
			boo=boo+1
		if chilow>np.max(r):
			boo=boo+1
		if (boo==0):
			return True
		else:
			return False


	def convert_xyz2rdz(self, data, shellnum):
		""" Generates and saves a single lightcone shell """		
		clight = self.clight
		boxL = self.boxL
		origin = self.origin
		shellnums = self.compute_shellnums()

		chilow, chiupp = self.obtain_data(shellnum, shellnums)

		ntiles = int(np.ceil(chiupp/boxL))
		
		px    = data['x']
		py    = data['y']
		pz    =	data['z']
		
		ngalbox=len(px)
		
				

		[axx, axy, axz, ayx, ayy, ayz, azx, azy, azz] = self.rotation_matrix

		for xx in range(-ntiles,ntiles):
			for yy in range(-ntiles,ntiles):
				for zz in range(-ntiles,ntiles):

					# slicehit = self.checkslicehit(chilow,chiupp,xx,yy,zz)             # Check if box intersects with shell
					# slicehit = True
					# if slicehit==True:

					sx  = ne.evaluate("px -%d + boxL * xx"%origin[0])
					sy  = ne.evaluate("py -%d + boxL * yy"%origin[1])
					sz  = ne.evaluate("pz -%d + boxL * zz"%origin[2])
					
					# sx = ne.evaluate("axx * sx_0 + axy * sy_0 + axz * sz_0")
					# sy = ne.evaluate("ayx * sx_0 + ayy * sy_0 + ayz * sz_0")
					# sz = ne.evaluate("azx * sx_0 + azy * sy_0 + azz * sz_0")

					r   = ne.evaluate("sqrt(sx*sx + sy*sy + sz*sz)")
					
					zi  = self.results.redshift_at_comoving_radial_distance(r/self.h) # interpolated distance from position
										
					idx = np.where((r>chilow) & (r<chiupp))[0]              # only select halos that are within the shell

					if idx.size!=0:
						
						ux=sx[idx]/r[idx]
						uy=sy[idx]/r[idx]
						uz=sz[idx]/r[idx]
						

						tht, phi = hp.vec2ang(np.c_[ux, uy, uz])
						ra,dec  = tp2rd(tht,phi)

						print(ra, dec, zi[idx], px[idx], py[idx], pz[idx])

		# return totid, totpx, totpy, totpz, totra, totdec, totz, totz + totdz, ngalbox #, totdz, totvlos
		# return totid, totra, totdec, totz, totz + totdz, ngalbox


	
	def obtain_data(self, shellnum, shellnums):

		chilow = self.shellwidth*(shellnum+0)
		chiupp = self.shellwidth*(shellnum+1)
		chimid = 0.5*(chilow+chiupp)
		
		

		return chilow, chiupp


	