#!/usr/bin/env python

# Generate lightcone for DESI mocks
# from HOD catalogues generated by Shadab

import sys
import os
import configparser
import multiprocessing as mp
from astropy.io import fits
import h5py

import camb
import numpy as np
import healpy as hp
import numexpr as ne

from rotation_matrix import RotationMatrix

ne.set_num_threads(4)

def tp2rd(tht, phi):
	""" convert theta,phi to ra/dec """
	ra  = phi / np.pi * 180.0
	dec = -1 * (tht / np.pi * 180.0 - 90.0)
	return ra, dec


class Paths():
	def __init__(self, config_file, args, in_part_path, input_name, out_part_path, output_name):
		config     = configparser.ConfigParser()
		config.read(config_file)

		self.dir_out                 = args.dir_out
		self.dir_in                  = args.dir_in
		
		### Both input and output names have empty regions
		### that need to be completed using ".format()" 
		self.input_name              = input_name
		self.output_name             = output_name

		self.in_part_path 			 = in_part_path		
		self.out_part_path 			 = out_part_path

		if self.dir_out is None:
			self.dir_out     =  config.get('dir', 'dir_out')
		if self.dir_in is None:
			self.dir_in      =  config.get('dir', 'dir_in')

		self.shells_out_path = self.create_outpath()

		self.input_file       = self.dir_in + self.in_part_path + self.input_name		
		self.output_file      = self.shells_out_path + self.output_name

	def create_outpath(self):
		out_path = self.dir_out + "/"+ self.out_part_path
		if not os.path.exists(out_path):
			os.makedirs(out_path)
		return out_path


class LightCone():
	def __init__(self, config_file, args):
		config     = configparser.ConfigParser()
		config.read(config_file)

		self.file_camb      = config.get('dir', 'file_camb')
		self.box_length     = config.getint('sim', 'box_length')
		self.shellwidth     = config.getint('sim', 'shellwidth')
		self.zmin           = config.getfloat('sim', 'zmin')
		self.zmax           = config.getfloat('sim', 'zmax')
		self.rotate         = config.getboolean('sim', 'rotate')

		self.mock_random_ic = args.mock_random_ic
		if self.mock_random_ic is None:
			self.mock_random_ic = config.get('sim', 'mock_random_ic')

		self.origin  = [0, 0, 0]
		self.clight  = 299792458.

		self.h, self.results = self.run_camb()
		file_alist     =  config.get('dir','file_alist')
		self.alist = np.loadtxt(file_alist)

		rotation_matrix_instance = RotationMatrix(config_file, args)
		self.rotation_matrix = rotation_matrix_instance.rotation_matrix


	def run_camb(self):
		#Load all parameters from camb file
		pars = camb.read_ini(self.file_camb)
		h    = pars.h
		pars.set_for_lmax(2000, lens_potential_accuracy=3)
		pars.set_matter_power(redshifts=[0.], kmax=200.0)
		pars.NonLinearModel.set_params(halofit_version='takahashi')
		camb.set_feedback_level(level=100)
		results   = camb.get_results(pars)
		return h, results


	def compute_shellnums(self):
		shellnum_min = int(self.results.comoving_radial_distance(self.zmin) * self.h // self.shellwidth)
		shellnum_max = int(self.results.comoving_radial_distance(self.zmax) * self.h // self.shellwidth + 1)
		shellnums = list(range(shellnum_min, shellnum_max+1))
		print(f"INFO: There are {len(shellnums)} shells.")
		return shellnums


	def checkslicehit(self, chilow, chihigh, xx, yy, zz):
		""" pre-select so that we're not loading non-intersecting blocks """
		box_length = self.box_length
		origin = self.origin
		bvx = np.array([0, box_length, box_length, 0,    0,    box_length, box_length, 0])
		bvy = np.array([0,    0, box_length, box_length, 0,    0,    box_length, box_length])
		bvz = np.array([0,    0,   0,  0,    box_length, box_length, box_length, box_length])

		boo = 0
		r   = np.zeros(8)
		for i in range(0, 8):
			sx   = (bvx[i] - origin[0] + box_length * xx)
			sy   = (bvy[i] - origin[1] + box_length * yy)
			sz   = (bvz[i] - origin[2] + box_length * zz)
			r[i] = np.sqrt(sx * sx + sy * sy + sz * sz)
		if chihigh < np.min(r):
			boo = boo + 1
		if chilow > np.max(r):
			boo = boo+1

		if boo == 0:
			return True
		else:
			return False


	def convert_xyz2rdz(self, data, prefix, chilow, chiupp):
		""" Generates and saves a single lightcone shell """
		clight = self.clight
		box_length = self.box_length
		origin = self.origin

		ntiles = int(np.ceil(chiupp / box_length))
		print(prefix + "tiling [%dx%dx%d]" % (2 * ntiles, 2 * ntiles, 2 * ntiles))
		print(prefix + 'Generating map for halos in the range [%3.f - %.3f Mpc/h]' % (chilow, chiupp))

		px    = data['x']
		py    = data['y']
		pz    =	data['z']
		ngalbox = len(px)

		if self.mock_random_ic == "mock":
			vx    = data['vx']
			vy    = data['vy']
			vz    = data['vz']
		elif self.mock_random_ic == "random":
			id_ = data["id"]
		elif self.mock_random_ic == "ic":
			dens = data["density"]
		else:
			print(f"ERROR!!! generate_lc, convert_xyz2rdz: You should choose between: mock, random or ic. You have chosen {self.mock_random_ic}")
			
		#-------------------------------------------------------------------

		totra   = np.array([])
		totdec  = np.array([])
		totz    = np.array([])
		tot_aux = np.array([])

		[axx, axy, axz, ayx, ayy, ayz, azx, azy, azz] = self.rotation_matrix

		for xx in range(-ntiles, ntiles):
			for yy in range(-ntiles, ntiles):
				for zz in range(-ntiles, ntiles):

					if not self.rotate:
						slicehit = self.checkslicehit(chilow, chiupp, xx, yy, zz)             # Check if box intersects with shell
						if not slicehit:
							continue

					sx_0  = ne.evaluate("px - %d + box_length * xx" % origin[0])
					sy_0  = ne.evaluate("py - %d + box_length * yy" % origin[1])
					sz_0  = ne.evaluate("pz - %d + box_length * zz" % origin[2])

					if self.rotate:
						sx = ne.evaluate("axx * sx_0 + axy * sy_0 + axz * sz_0")
						sy = ne.evaluate("ayx * sx_0 + ayy * sy_0 + ayz * sz_0")
						sz = ne.evaluate("azx * sx_0 + azy * sy_0 + azz * sz_0")
					else:
						sx = sx_0
						sy = sy_0
						sz = sz_0

					r   = ne.evaluate("sqrt(sx * sx + sy * sy + sz * sz)")
					zi  = self.results.redshift_at_comoving_radial_distance(r / self.h) # interpolated distance from position

					idx = np.where((r > chilow) & (r < chiupp))[0]              # only select halos that are within the shell

					if idx.size!=0:
						ux = sx[idx] / r[idx]
						uy = sy[idx] / r[idx]
						uz = sz[idx] / r[idx]
						zp = zi[idx]

						if self.mock_random_ic == "mock":
							vx_0 = vx[idx]
							vy_0 = vy[idx]
							vz_0 = vz[idx]

							if self.rotate:
								vx_1 = ne.evaluate("axx * vx_0 + axy * vy_0 + axz * vz_0")
								vy_1 = ne.evaluate("ayx * vx_0 + ayy * vy_0 + ayz * vz_0")
								vz_1 = ne.evaluate("azx * vx_0 + azy * vy_0 + azz * vz_0")
							else:
								vx_1 = vx_0
								vy_1 = vy_0
								vz_1 = vz_0

							qx = vx_1 * 1000.
							qy = vy_1 * 1000.
							qz = vz_1 * 1000.

							vlos    = ne.evaluate("qx * ux + qy * uy + qz * uz")
							dz      = ne.evaluate("(vlos / clight) * (1 + zp)")
							tot_aux = np.append(tot_aux, zp + dz)
						elif self.mock_random_ic == "random":
							tot_aux = np.append(tot_aux, id_[idx])
						elif self.mock_random_ic == "ic":
							tot_aux = np.append(tot_aux, dens[idx])

						tht, phi = hp.vec2ang(np.c_[ux, uy, uz])
						ra, dec  = tp2rd(tht, phi)

						totra   = np.append(totra , ra)
						totdec  = np.append(totdec, dec)
						totz    = np.append(totz  , zp)

		return totra, totdec, totz, tot_aux, ngalbox


	def getnearestsnap(self, zmid):
		""" get the closest snapshot """
		# zsnap  = 1/self.alist[:,1]-1.
		zsnap  = 1 / self.alist[:, 2] - 1.
		index_ = np.argmin(np.abs(zsnap - zmid))

		return int(self.alist[index_, 0]), self.alist[index_, 3]


	def obtain_data(self, infile, prefix):
		try:
			hdul = fits.open(infile, memmap=False)
			data = hdul[1].data
			hdul.close()
			ngalbox = len(data["x"])
			print(prefix + f"INFO: The input file is {infile} and it has {ngalbox} halos")

		except IOError:
			print(prefix + f"WARNING: Couldn't open {infile}.", file=sys.stderr)
			os._exit(1)
		return data


	def generate_shell(self, infile, subbox, prefix, chilow, chiupp, return_dict):
		### Read Data
		data = self.obtain_data(infile, prefix)

		### Convert XYZ to RA DEC Z
		ra0, dec0, zz0, aux0, ngalbox = self.convert_xyz2rdz(data, prefix, chilow, chiupp)


		shell_subbox_dict = {"ra0": ra0, "dec0": dec0, "zz0": zz0, "aux0": aux0}
		return_dict[subbox] = shell_subbox_dict

		return_dict["NGAL" + str(subbox)] = ngalbox


	def generate_shells(self, path_instance, snapshot=None, redshift=None, cutsky=True, nproc=5, n_subboxes=27, cat_seed=None):
		shellnums = self.compute_shellnums()
		for shellnum in shellnums:
			chilow = self.shellwidth * (shellnum + 0)
			chiupp = self.shellwidth * (shellnum + 1)
			chimid = 0.5 * (chilow + chiupp)

			# Check whether the minimum redshift of the shell is outside the redshift range of interest 
			zlow = self.results.redshift_at_comoving_radial_distance(chilow / self.h)
			if zlow > self.zmax:
				continue

			if not cutsky:
				print("Light-cone")
				zmid = self.results.redshift_at_comoving_radial_distance(chimid / self.h)
				nearestsnap, nearestred = self.getnearestsnap(zmid)
				
				snapshot = nearestsnap
				redshift = "z%.3f"%(nearestred)

			out_file_name = path_instance.output_file.format(snapshot=snapshot, shellnum=str(shellnum))

			# Don't reprocess files already done
			if os.path.isfile(out_file_name):
				continue

			jobs = []
			manager = mp.Manager()
			return_dict = manager.dict()
			counter = 0
			for subbox in range(n_subboxes):
				infile = path_instance.input_file.format(redshift=redshift, subbox=subbox)
				prefix = f"[shellnum={shellnum}; subbox={subbox}]: "

				p = mp.Process(target=self.generate_shell, args=(infile, subbox, prefix, chilow, chiupp, return_dict))
				jobs.append(p)
				p.start()
				counter = counter + 1
				if (counter == nproc) or (subbox == n_subboxes - 1):
					for proc in jobs:
						proc.join()
					counter = 0
					jobs = []

			### Count the number of galaxies per shell
			n_gal_shell_all_subboxes = 0
			for subbox in range(n_subboxes):
				shell_subbox_dict = return_dict[subbox]
				n_gal_shell_all_subboxes += len(shell_subbox_dict["ra0"])

			### Declare arrays of size
			ra0_array = np.zeros(n_gal_shell_all_subboxes)
			dec0_array = np.zeros(n_gal_shell_all_subboxes)
			zz0_array = np.zeros(n_gal_shell_all_subboxes)
			
			aux0_array = np.zeros(n_gal_shell_all_subboxes)
			counter_ngal = 0

			### Fill the arrays
			index_i = 0
			index_f = 0
			for subbox in range(n_subboxes):
				counter_ngal += return_dict["NGAL" + str(subbox)]
				shell_subbox_dict = return_dict[subbox]

				index_f = index_i + len(shell_subbox_dict["ra0"])

				ra0_array[index_i: index_f]  = shell_subbox_dict["ra0"]
				dec0_array[index_i: index_f] = shell_subbox_dict["dec0"]
				zz0_array[index_i: index_f]  = shell_subbox_dict["zz0"]
				aux0_array[index_i: index_f] = shell_subbox_dict["aux0"]

				index_i = index_f

			out_file_name_tmp  = out_file_name + "_tmp"

			with h5py.File(out_file_name_tmp, 'w') as out_file:
				out_file.create_group('galaxy')
				out_file.create_dataset('galaxy/RA',      data=ra0_array,    dtype=np.float32)
				out_file.create_dataset('galaxy/DEC',     data=dec0_array,   dtype=np.float32)
				out_file.create_dataset('galaxy/Z_COSMO', data=zz0_array,     dtype=np.float32)

				if self.mock_random_ic == "mock":
					out_file.create_dataset('galaxy/Z_RSD',   data=aux0_array, dtype=np.float32)
				elif self.mock_random_ic == "random":
					out_file.create_dataset('galaxy/ID',      data=aux0_array, dtype=np.int32)
				elif self.mock_random_ic == "ic":
					out_file.create_dataset('galaxy/ONEplusDELTA', data=1 + aux0_array, dtype=np.float32)

				out_file.attrs['NGAL']     = counter_ngal
				out_file.attrs['SHELLNUM'] = shellnum
				out_file.attrs['SNAPSHOT'] = snapshot
				out_file.attrs['CAT_SEED'] = cat_seed
				out_file.attrs['BOX_LENGTH'] = self.box_length

			os.rename(out_file_name_tmp, out_file_name)
